PROBLEMA: C'è il negozio di un barbiere che ha:
	- Tre sedie;
	- Tre barbieri.
E una sala di attesa che può accomodare:
	- Quattro clienti su un divano;
	- Una sala di attesa dove i clienti aspettano in piedi.
Per motivi di sicurezza, non ci possono essere più di 20 clienti nel locale.

Un cliente non entra nel negozio se la capacità di 20 persone è superata.
Una volta dentro, il cliente prende posto nel divano oppure sta in piedi se il divano è totalmente occupato. Quando un barbiere è libero, il cliente che è da più tempo nel divano viene servito e, se ci sono dei clienti in piedi, colui che è nel negozio da più tempo prende posto nel divano.
Quando il taglio di capelli di un cliente è finito, qualsiasi barbiere può accettare il pagamento ma, dal momento che vi è un solo registro di cassa, il pagamento può essere accettato per un cliente alla volta.
I barbieri dividono il loro tempo tra le seguenti attività:
	- Tagliare i capelli;
	- Accettare pagamenti;
	- Dormire sulla sedia in attesa dell'arrivo di un cliente.

Dunque le funzionalità devono essere le seguenti:
	- I clienti invocano le seguenti funzioni in ordine: enterShop, sitOnSofa, getHairCut, pay;
	- I barbieri invocano i metodi cutHair e acceptPayment;
	- I clienti non possono invocare enterShop se il negozio è pieno;
	- Se il divano è pieno i clienti non possono invocare sitOnSofa;
	- Quando il cliente invoca getHairCut ci dovrebbe essere un barbiere corrispondente che invoca cutHair concorrentemente, e viceversa;
	- Dovrebbe essere possibile consentire FINO A 3 CLIENTI l'esecuzione della funzione getHairCut concorrentemente, e fino a tre barbieri di eseguire cutHair concorrentemente;
	- Il cliente deve invocare la funzione pay prima che il barbiere possa invocare acceptPayment;
	- Il barbiere deve invocare acceptPayment prima che il cliente possa uscire.

Scelte Personali:

	- Se un cliente non trova posto nel negozio, si addormenta e riprova più avanti 
	- Si utilizzano due mutex per consentire l'esecuzione di altri thread, dato che nella parte di pagamento si utilizzano variabili che, nelle parti precedenti (mettersi in coda, sedersi nel divano, farsi tagliare i capelli), non vengono utilizzate !!!
	- Si passa come parametro il numero di thread clienti
	- Nel thread bariere PRIMA DI RILASCIARE MUTEX (alla fine) occorre svegliare il thread bloccato!! altrimenti si rischia che, nel frattempo che il mutex sia stato rilasciato, 
		che un altro thread (cliente) prende il mutex, si siede nel divano, arriva al controllo dei clienti serviti e passa SALTANDO LA CODA DEI CLIENTI IN ATTESA SUL DIVANO!!  Discorso IDENTICO nella funzione liberaPostoDivano nelle seguenti righe
		   	printf("Il Thread CLIENTE di indice %d con identificatore %lu si e' seduto nella sedia e attende il taglio dei capelli.\n", indice, pthread_self());
			pthread_cond_signal(&C_DIVANO_OCCUPATO);
			pthread_mutex_unlock(&mutex);